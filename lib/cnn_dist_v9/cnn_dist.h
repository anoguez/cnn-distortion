
extern "C" {
#include <cblas.h>
};

#include <cmath>

struct cnn_dist_v9 {
	const static int latency = 504;
	const static int MAX_L = MAX_BUFFER + latency;
	// About 1e-05*(MAX_BUFFER+504) MB of buffer
	float x_even[5][MAX_L];
	float x_odd [5][MAX_L];

	void operator()(float* x, float* y, int L) {

		// Ensure we don't segfault
		L = L > MAX_L ? MAX_L : L;

		for (int i = 0; i < L; i++) {
			x_odd[0][i] = x[i];
		}

		// auto-generated code for layer layer_0: Conv1d(1, 5, kernel_size=(2,), stride=(1,), dilation=(256,))
		const float w_layer_0[2][5][1] = {{{1.2446277141571045},{-1.9587205648422241},{2.1191461086273193},{0.7072356343269348},{2.6119041442871094}},{{0.015736199915409088},{0.1338878720998764},{-0.8911029100418091},{-0.5991026759147644},{0.4391750395298004}}};
		const float b_layer_0[5] = {0.12500622868537903,-0.032971352338790894,0.22972950339317322,-0.08594246953725815,-0.4487554132938385};

		// Fill with biases for layer_0
		for (int i = 0; i < 5; i++) {
			for (int l = 256; l < L; l++) {
				x_even[i][l] = b_layer_0[i];
			}
		}

		// Apply main filter for layer_0
		// x_even[:,256:] = sum(w[k]@x_odd[:,256-(1-k)*256:L-(1-k)*256] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*256;
			cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, 5, L-256, 1, 1.0, &w_layer_0[k][0][0], 1, &x_odd[0][256-offset], MAX_L, 1.0, &x_even[0][256], MAX_L);
		}


		// Leaky Rectified Linear Unit (ReLU)
		for (int i = 0; i < 5; i++) {
			for (int l = 256; l < L; l++) {
				auto v = x_even[i][l];
				x_even[i][l] = v > 2 ? 1.3333333333333333 : v < -2 ? -1.3333333333333333 : v - v*v*v*0.08333333333333333;
			}
		}


		// auto-generated code for layer layer_1: Conv1d(5, 5, kernel_size=(2,), stride=(1,), dilation=(128,))
		const float w_layer_1[2][5][5] = {{{0.004717395640909672,-0.35422489047050476,0.26153919100761414,0.2080153375864029,-0.1450987160205841},{0.20298732817173004,0.058573152869939804,-0.22783459722995758,0.29792553186416626,0.15625125169754028},{0.10196369141340256,-0.5881288647651672,0.35220736265182495,0.17759574949741364,0.3461470305919647},{0.32299429178237915,-0.7282726168632507,0.4433501362800598,-0.08594238013029099,0.6571223139762878},{-0.39964956045150757,0.16533015668392181,-0.12166184931993484,-0.399754136800766,-0.49966663122177124}},{{-0.1684327870607376,0.28639253973960876,-0.13913951814174652,0.0012099383166059852,-0.20329387485980988},{0.042184486985206604,0.3558288514614105,-0.22430123388767242,-0.04944249242544174,-0.7006024718284607},{-0.13747863471508026,0.4610980749130249,-0.048290446400642395,-0.2521914839744568,-0.6665512323379517},{-0.3499234616756439,0.44724977016448975,-0.033234767615795135,0.22054775059223175,-0.3387698233127594},{-0.4839147925376892,0.909721314907074,-0.3087748885154724,0.08504537492990494,-0.7032896280288696}}};
		const float b_layer_1[5] = {-0.1648835688829422,-0.06072508916258812,-0.20340591669082642,0.0291290320456028,-0.18679288029670715};

		// Fill with biases for layer_1
		for (int i = 0; i < 5; i++) {
			for (int l = 384; l < L; l++) {
				x_odd[i][l] = b_layer_1[i];
			}
		}

		// Apply main filter for layer_1
		// x_odd[:,384:] = sum(w[k]@x_even[:,384-(1-k)*128:L-(1-k)*128] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*128;
			cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, 5, L-384, 5, 1.0, &w_layer_1[k][0][0], 5, &x_even[0][384-offset], MAX_L, 1.0, &x_odd[0][384], MAX_L);
		}


		// Leaky Rectified Linear Unit (ReLU)
		for (int i = 0; i < 5; i++) {
			for (int l = 384; l < L; l++) {
				auto v = x_odd[i][l];
				x_odd[i][l] = v > 2 ? 1.3333333333333333 : v < -2 ? -1.3333333333333333 : v - v*v*v*0.08333333333333333;
			}
		}


		// auto-generated code for layer layer_2: Conv1d(5, 5, kernel_size=(2,), stride=(1,), dilation=(64,))
		const float w_layer_2[2][5][5] = {{{-0.24557535350322723,-0.5340530276298523,0.02998192422091961,0.21396425366401672,-1.1262673139572144},{-0.23615670204162598,-0.2368825525045395,-0.5647942423820496,-0.2904195487499237,0.38447535037994385},{0.047103945165872574,0.3824046850204468,0.8153101205825806,1.245864987373352,-0.26367616653442383},{0.2996169626712799,0.5032657384872437,0.1485728919506073,-0.3321097493171692,0.6472232937812805},{-0.21784909069538116,-0.3326016068458557,-0.6271321177482605,-0.20902012288570404,-0.5601747632026672}},{{-0.1594558209180832,0.6148521900177002,0.3227052688598633,0.5045469999313354,0.21667245030403137},{0.032968416810035706,0.9430599212646484,0.1948813647031784,0.021916434168815613,0.9137454032897949},{0.0651482343673706,-0.2223028540611267,-0.3533855080604553,-0.6152945160865784,0.13236457109451294},{-0.31959593296051025,-1.314221978187561,-0.5625537037849426,-0.8945479393005371,-1.1187361478805542},{-0.032845109701156616,-0.22738449275493622,0.12121716141700745,-0.35708215832710266,-0.04339764639735222}}};
		const float b_layer_2[5] = {0.11440720409154892,-0.03221884369850159,0.1962108165025711,0.15391407907009125,-0.07178477942943573};

		// Fill with biases for layer_2
		for (int i = 0; i < 5; i++) {
			for (int l = 448; l < L; l++) {
				x_even[i][l] = b_layer_2[i];
			}
		}

		// Apply main filter for layer_2
		// x_even[:,448:] = sum(w[k]@x_odd[:,448-(1-k)*64:L-(1-k)*64] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*64;
			cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, 5, L-448, 5, 1.0, &w_layer_2[k][0][0], 5, &x_odd[0][448-offset], MAX_L, 1.0, &x_even[0][448], MAX_L);
		}


		// Leaky Rectified Linear Unit (ReLU)
		for (int i = 0; i < 5; i++) {
			for (int l = 448; l < L; l++) {
				auto v = x_even[i][l];
				x_even[i][l] = v > 2 ? 1.3333333333333333 : v < -2 ? -1.3333333333333333 : v - v*v*v*0.08333333333333333;
			}
		}


		// auto-generated code for layer layer_3: Conv1d(5, 5, kernel_size=(2,), stride=(1,), dilation=(32,))
		const float w_layer_3[2][5][5] = {{{-0.8836298584938049,-1.4371851682662964,-0.01749046891927719,1.0575562715530396,0.24926337599754333},{-0.3486204743385315,0.8718681335449219,-0.8158256411552429,-0.12897759675979614,0.33928295969963074},{0.8939017057418823,1.176835536956787,-0.029265403747558594,-0.6546958088874817,-0.25429263710975647},{0.05675923824310303,0.2037004828453064,-0.6349085569381714,0.3257819414138794,0.7320263981819153},{0.12294407188892365,0.6207836270332336,0.36940088868141174,-0.5138927698135376,-0.6272091865539551}},{{-1.1096036434173584,0.38549456000328064,0.5013725161552429,0.29474058747291565,-0.9079073667526245},{-0.12239537388086319,0.2454756647348404,-0.1654745191335678,-0.09412431716918945,-0.21180295944213867},{0.888248860836029,-0.6149070858955383,-0.12875407934188843,0.19265654683113098,1.0327107906341553},{-0.4036806523799896,0.6278997659683228,-1.005584955215454,-0.059994008392095566,0.8647066354751587},{-0.2961283028125763,0.2259002923965454,-0.010119033046066761,0.21662063896656036,0.48269277811050415}}};
		const float b_layer_3[5] = {-0.40073704719543457,-0.048687644302845,0.359988272190094,0.015297440811991692,0.00039120507426559925};

		// Fill with biases for layer_3
		for (int i = 0; i < 5; i++) {
			for (int l = 480; l < L; l++) {
				x_odd[i][l] = b_layer_3[i];
			}
		}

		// Apply main filter for layer_3
		// x_odd[:,480:] = sum(w[k]@x_even[:,480-(1-k)*32:L-(1-k)*32] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*32;
			cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, 5, L-480, 5, 1.0, &w_layer_3[k][0][0], 5, &x_even[0][480-offset], MAX_L, 1.0, &x_odd[0][480], MAX_L);
		}


		// Leaky Rectified Linear Unit (ReLU)
		for (int i = 0; i < 5; i++) {
			for (int l = 480; l < L; l++) {
				auto v = x_odd[i][l];
				x_odd[i][l] = v > 2 ? 1.3333333333333333 : v < -2 ? -1.3333333333333333 : v - v*v*v*0.08333333333333333;
			}
		}


		// auto-generated code for layer layer_4: Conv1d(5, 5, kernel_size=(2,), stride=(1,), dilation=(16,))
		const float w_layer_4[2][5][5] = {{{0.11672057211399078,-0.14896903932094574,-0.07483037561178207,0.5538328289985657,-0.858393132686615},{0.008896863088011742,0.6701929569244385,-0.22879645228385925,0.37431830167770386,0.07117627561092377},{0.4770154654979706,-0.2764173746109009,-0.4887421131134033,0.08618049323558807,-0.10930169373750687},{0.0952717587351799,0.43721696734428406,-0.10340391844511032,-0.08361810445785522,-0.6098938584327698},{-0.059562668204307556,0.15579919517040253,0.6086863279342651,0.10463643819093704,0.1415363997220993}},{{-1.074254035949707,-0.3647652566432953,0.7466475367546082,-0.04184342175722122,0.7698777914047241},{-0.5436434745788574,0.06362336874008179,0.3794385492801666,0.47888413071632385,0.38547080755233765},{0.4473567008972168,0.08831649273633957,-0.2942921221256256,-0.018311014398932457,0.06481591612100601},{0.40052923560142517,-0.1632220447063446,-0.12240100651979446,0.09798446297645569,-0.197268545627594},{0.277601033449173,-0.11909067630767822,0.022846389561891556,0.19000135362148285,-0.7054466009140015}}};
		const float b_layer_4[5] = {0.062249939888715744,-0.25707173347473145,0.1637129932641983,0.017669670283794403,0.3053196370601654};

		// Fill with biases for layer_4
		for (int i = 0; i < 5; i++) {
			for (int l = 496; l < L; l++) {
				x_even[i][l] = b_layer_4[i];
			}
		}

		// Apply main filter for layer_4
		// x_even[:,496:] = sum(w[k]@x_odd[:,496-(1-k)*16:L-(1-k)*16] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*16;
			cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, 5, L-496, 5, 1.0, &w_layer_4[k][0][0], 5, &x_odd[0][496-offset], MAX_L, 1.0, &x_even[0][496], MAX_L);
		}


		// Leaky Rectified Linear Unit (ReLU)
		for (int i = 0; i < 5; i++) {
			for (int l = 496; l < L; l++) {
				auto v = x_even[i][l];
				x_even[i][l] = v > 2 ? 1.3333333333333333 : v < -2 ? -1.3333333333333333 : v - v*v*v*0.08333333333333333;
			}
		}


		// auto-generated code for layer layer_5: Conv1d(5, 5, kernel_size=(2,), stride=(1,), dilation=(8,))
		const float w_layer_5[2][5][5] = {{{-0.33731627464294434,0.027667080983519554,0.29202455282211304,0.22583073377609253,-0.09456411004066467},{-0.11071591079235077,-0.3682350814342499,-0.2455713152885437,-0.37971147894859314,-0.10048927366733551},{-0.016508467495441437,0.21614742279052734,0.17537684738636017,-0.10522940754890442,-0.07281288504600525},{0.20967386662960052,-0.12259411066770554,0.172530397772789,-0.11273034662008286,-0.20348694920539856},{-0.3167324662208557,0.19873054325580597,0.21889229118824005,0.285940021276474,0.1370088905096054}},{{0.003779506077989936,-0.2938423454761505,0.3411021828651428,0.17980864644050598,-0.22900919616222382},{-0.7459948658943176,-0.14546677470207214,0.23062017560005188,0.30870962142944336,0.3309377431869507},{0.1362251341342926,-0.251616895198822,-0.07747721672058105,0.13838520646095276,0.03307827562093735},{0.057043224573135376,0.31246480345726013,-0.25175726413726807,-0.29417726397514343,-0.5939556956291199},{0.22960548102855682,-0.233677938580513,-0.10147765278816223,-0.3475525677204132,0.3593044877052307}}};
		const float b_layer_5[5] = {0.2192467898130417,-0.13285960257053375,-0.011205857619643211,-0.10664365440607071,-0.009079618379473686};

		// Fill with biases for layer_5
		for (int i = 0; i < 5; i++) {
			for (int l = 504; l < L; l++) {
				x_odd[i][l] = b_layer_5[i];
			}
		}

		// Apply main filter for layer_5
		// x_odd[:,504:] = sum(w[k]@x_even[:,504-(1-k)*8:L-(1-k)*8] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*8;
			cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, 5, L-504, 5, 1.0, &w_layer_5[k][0][0], 5, &x_even[0][504-offset], MAX_L, 1.0, &x_odd[0][504], MAX_L);
		}


		// Leaky Rectified Linear Unit (ReLU)
		for (int i = 0; i < 5; i++) {
			for (int l = 504; l < L; l++) {
				auto v = x_odd[i][l];
				x_odd[i][l] = v > 2 ? 1.3333333333333333 : v < -2 ? -1.3333333333333333 : v - v*v*v*0.08333333333333333;
			}
		}


		// auto-generated code for layer layer_6: Conv1d(5, 1, kernel_size=(1,), stride=(1,))
		const float w_layer_6[1][1][5] = {{{-0.11119174212217331,0.3160434663295746,-0.0011637955904006958,0.12315213680267334,-0.0007281108410097659}}};
		const float b_layer_6[1] = {0.03658193349838257};

		// Fill with biases for layer_6
		for (int i = 0; i < 1; i++) {
			for (int l = 504; l < L; l++) {
				x_even[i][l] = b_layer_6[i];
			}
		}

		// Apply main filter for layer_6
		// x_even[:,504:] = sum(w[k]@x_odd[:,504-(0-k)*1:L-(0-k)*1] for k in w.shape[0])
		for (int k = 0; k < 1; k++) {
			int offset = (0-k)*1;
			cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, 1, L-504, 5, 1.0, &w_layer_6[k][0][0], 5, &x_odd[0][504-offset], MAX_L, 1.0, &x_even[0][504], MAX_L);
		}


		// Copy result back to y
		for (int l = 504; l < L; l++) {
			y[l] = x_even[0][l];
		}
	}
};
