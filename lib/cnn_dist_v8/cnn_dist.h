
#pragma once
extern "C" {
#include <cblas.h>
};

#include <cmath>

struct cnn_dist_v8 {
	const static int latency = 504;
	const static int MAX_L = MAX_BUFFER + latency;
	const static int MAX_CH = 5;
	// About 1e-05*(MAX_BUFFER+504) MB of buffer
	float x_even[MAX_L][MAX_CH];
	float x_odd [MAX_L][MAX_CH];

	void operator()(float* x, float* y, int L) {

		// Ensure we don't segfault
		L = L > MAX_L ? MAX_L : L;

		for (int i = 0; i < L; i++) {
			x_odd[i][0] = x[i];
		}

		// auto-generated code for layer layer_0: Conv1d(1, 5, kernel_size=(2,), stride=(1,), dilation=(256,))
		const float w_layer_0[2][1][5] = {{{-2.2387118339538574,1.9521775245666504,-2.24692440032959,-0.24548204243183136,-1.2331887483596802}},{{-0.6806926727294922,-0.28058353066444397,0.12010175734758377,0.052497513592243195,0.5161495208740234}}};
		const float b_layer_0[5] = {-0.011025456711649895,-0.20374628901481628,-0.019373850896954536,-0.0181413646787405,-0.3406185209751129};

		// Fill with biases for layer_0
		for (int l = 256; l < L; l++) {
			for (int i = 0; i < 5; i++) {
				x_even[l][i] = b_layer_0[i];
			}
		}

		// Apply main filter for layer_0
		// x_even[:,256:] = sum(w[k]@x_odd[:,256-(1-k)*256:L-(1-k)*256] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*256;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 5, L-256, 1, 1.0, &w_layer_0[k][0][0], 5, &x_odd[256-offset][0], MAX_CH, 1.0, &x_even[256][0], MAX_CH);
		}


		// Leaky Tanh
		for (int l = 256; l < L; l++) {
			for (int i = 0; i < 5; i++) {
				auto& v = x_even[i][l];
				x_even[l][i] = v > 1 ? 1+0.1f*(v-1) : v < -1 ? -1+0.1f*(v+1) : v;
			}
		}


		// auto-generated code for layer layer_1: Conv1d(5, 5, kernel_size=(2,), stride=(1,), dilation=(128,))
		const float w_layer_1[2][5][5] = {{{-0.31274518370628357,-0.08848100900650024,1.2729151248931885,0.2542436122894287,-2.2880871295928955},{0.3870638310909271,0.12473262846469879,-0.17320938408374786,-0.1966477930545807,0.911973774433136},{-0.205577090382576,-0.11951079964637756,0.507821261882782,0.1888856589794159,-1.9429125785827637},{0.24628153443336487,-0.2159215807914734,-0.09936320781707764,-0.044965118169784546,0.15157073736190796},{-0.000409187312470749,-0.6161835789680481,0.254475861787796,0.049767185002565384,-0.31487348675727844}},{{1.530724287033081,0.8652653694152832,0.07778401672840118,0.5874195694923401,0.8354499340057373},{-0.45631495118141174,-1.0028492212295532,-0.14838992059230804,-0.7950646877288818,-0.2522779107093811},{1.3139622211456299,0.7971599102020264,0.35278746485710144,0.9065847992897034,0.7590288519859314},{0.4589040279388428,0.25793254375457764,-0.05007254704833031,0.09173803776502609,-0.08307427167892456},{0.5577515363693237,0.04527415335178375,0.10600169003009796,0.2102627456188202,0.2957550585269928}}};
		const float b_layer_1[5] = {-0.4781651198863983,0.45071908831596375,0.08180377632379532,0.010467112995684147,-0.23785002529621124};

		// Fill with biases for layer_1
		for (int l = 384; l < L; l++) {
			for (int i = 0; i < 5; i++) {
				x_odd[l][i] = b_layer_1[i];
			}
		}

		// Apply main filter for layer_1
		// x_odd[:,384:] = sum(w[k]@x_even[:,384-(1-k)*128:L-(1-k)*128] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*128;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 5, L-384, 5, 1.0, &w_layer_1[k][0][0], 5, &x_even[384-offset][0], MAX_CH, 1.0, &x_odd[384][0], MAX_CH);
		}


		// Leaky Tanh
		for (int l = 384; l < L; l++) {
			for (int i = 0; i < 5; i++) {
				auto& v = x_odd[i][l];
				x_odd[l][i] = v > 1 ? 1+0.1f*(v-1) : v < -1 ? -1+0.1f*(v+1) : v;
			}
		}


		// auto-generated code for layer layer_2: Conv1d(5, 5, kernel_size=(2,), stride=(1,), dilation=(64,))
		const float w_layer_2[2][5][5] = {{{0.3301931619644165,0.021082762628793716,-0.3157654404640198,0.02100970968604088,0.19276905059814453},{0.14571502804756165,0.5210389494895935,-0.4736476242542267,0.13298368453979492,0.32286515831947327},{0.10848098248243332,0.10621102899312973,0.046808674931526184,-0.24499556422233582,0.07909999042749405},{0.007394103799015284,0.6440111994743347,-0.14721739292144775,-0.2985706329345703,0.6241333484649658},{0.41554707288742065,0.005880087148398161,-0.23514403402805328,0.6367477178573608,-0.08510817587375641}},{{0.1771741658449173,-0.05185868591070175,0.42535680532455444,-0.44932878017425537,-0.4062539339065552},{0.12579931318759918,-0.2799242436885834,0.40811687707901,0.05790325254201889,-0.6106557846069336},{0.1471807211637497,0.3060978055000305,-0.12745968997478485,0.7126376628875732,-0.13293330371379852},{0.09985189884901047,0.24000422656536102,0.4474681317806244,-1.0413955450057983,-0.44334208965301514},{-0.02374013513326645,-0.07842207700014114,-0.06985007971525192,0.29381757974624634,-0.19935916364192963}}};
		const float b_layer_2[5] = {0.2131005823612213,-0.13899913430213928,-0.13799774646759033,-0.24042747914791107,-0.2728440761566162};

		// Fill with biases for layer_2
		for (int l = 448; l < L; l++) {
			for (int i = 0; i < 5; i++) {
				x_even[l][i] = b_layer_2[i];
			}
		}

		// Apply main filter for layer_2
		// x_even[:,448:] = sum(w[k]@x_odd[:,448-(1-k)*64:L-(1-k)*64] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*64;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 5, L-448, 5, 1.0, &w_layer_2[k][0][0], 5, &x_odd[448-offset][0], MAX_CH, 1.0, &x_even[448][0], MAX_CH);
		}


		// Leaky Tanh
		for (int l = 448; l < L; l++) {
			for (int i = 0; i < 5; i++) {
				auto& v = x_even[i][l];
				x_even[l][i] = v > 1 ? 1+0.1f*(v-1) : v < -1 ? -1+0.1f*(v+1) : v;
			}
		}


		// auto-generated code for layer layer_3: Conv1d(5, 5, kernel_size=(2,), stride=(1,), dilation=(32,))
		const float w_layer_3[2][5][5] = {{{-0.6414840817451477,-0.5502663254737854,-0.5247154831886292,-0.4869405925273895,-0.35868099331855774},{-0.31836774945259094,-0.18387606739997864,-0.3005116581916809,-0.5135250687599182,0.04349073767662048},{-0.8741523027420044,-0.46222782135009766,-0.05680044740438461,0.9197384715080261,-0.017658039927482605},{0.2701680362224579,0.16482214629650116,0.21270935237407684,-1.424994945526123,0.21699759364128113},{2.364159107208252,0.4442560374736786,0.6009728908538818,0.01707339659333229,-0.21745696663856506}},{{0.6275075078010559,0.2649746537208557,0.1727997213602066,-0.6876558661460876,-0.3029504120349884},{1.5293515920639038,0.6575669050216675,-0.059361834079027176,0.13117466866970062,-0.2376803755760193},{-0.6404120922088623,-0.3142947256565094,0.06503098458051682,-0.29896074533462524,0.07598816603422165},{-0.4563915729522705,-0.3521532416343689,0.00943970587104559,0.12497494369745255,-0.031640876084566116},{0.3428911864757538,0.22934040427207947,-0.5807723999023438,0.2981986701488495,-0.09771885722875595}}};
		const float b_layer_3[5] = {-0.172011137008667,-0.03509141504764557,0.1173756942152977,-0.1912587285041809,-0.0876629576086998};

		// Fill with biases for layer_3
		for (int l = 480; l < L; l++) {
			for (int i = 0; i < 5; i++) {
				x_odd[l][i] = b_layer_3[i];
			}
		}

		// Apply main filter for layer_3
		// x_odd[:,480:] = sum(w[k]@x_even[:,480-(1-k)*32:L-(1-k)*32] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*32;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 5, L-480, 5, 1.0, &w_layer_3[k][0][0], 5, &x_even[480-offset][0], MAX_CH, 1.0, &x_odd[480][0], MAX_CH);
		}


		// Leaky Tanh
		for (int l = 480; l < L; l++) {
			for (int i = 0; i < 5; i++) {
				auto& v = x_odd[i][l];
				x_odd[l][i] = v > 1 ? 1+0.1f*(v-1) : v < -1 ? -1+0.1f*(v+1) : v;
			}
		}


		// auto-generated code for layer layer_4: Conv1d(5, 5, kernel_size=(2,), stride=(1,), dilation=(16,))
		const float w_layer_4[2][5][5] = {{{0.381581574678421,0.08140964806079865,0.32549726963043213,0.22728188335895538,-0.10275447368621826},{-0.3460572361946106,0.011520260013639927,-0.03354969993233681,0.20714308321475983,-0.056610140949487686},{1.278813362121582,-0.013021004386246204,0.15870296955108643,0.16771075129508972,0.415737122297287},{0.1225787028670311,-0.017381969839334488,0.11553006619215012,0.41066303849220276,0.12233362346887589},{0.20403777062892914,0.21434710919857025,0.2440824657678604,0.14771941304206848,-0.23293688893318176}},{{-0.7709912061691284,-0.17239554226398468,-0.15072180330753326,0.3102951943874359,0.4005875885486603},{-1.0109291076660156,0.048439085483551025,0.08945149928331375,0.1748521625995636,-0.2468707114458084},{-1.1199849843978882,-0.027245547622442245,-0.2622084319591522,0.3780565857887268,-0.25795605778694153},{0.19386927783489227,-0.22432942688465118,0.37088772654533386,-0.22947490215301514,-0.18588365614414215},{-0.10212370753288269,-0.24928781390190125,0.44487252831459045,-0.08629240095615387,0.5494742393493652}}};
		const float b_layer_4[5] = {0.29162880778312683,0.11488771438598633,0.001464960747398436,-0.166814923286438,0.13942372798919678};

		// Fill with biases for layer_4
		for (int l = 496; l < L; l++) {
			for (int i = 0; i < 5; i++) {
				x_even[l][i] = b_layer_4[i];
			}
		}

		// Apply main filter for layer_4
		// x_even[:,496:] = sum(w[k]@x_odd[:,496-(1-k)*16:L-(1-k)*16] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*16;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 5, L-496, 5, 1.0, &w_layer_4[k][0][0], 5, &x_odd[496-offset][0], MAX_CH, 1.0, &x_even[496][0], MAX_CH);
		}


		// Leaky Tanh
		for (int l = 496; l < L; l++) {
			for (int i = 0; i < 5; i++) {
				auto& v = x_even[i][l];
				x_even[l][i] = v > 1 ? 1+0.1f*(v-1) : v < -1 ? -1+0.1f*(v+1) : v;
			}
		}


		// auto-generated code for layer layer_5: Conv1d(5, 5, kernel_size=(2,), stride=(1,), dilation=(8,))
		const float w_layer_5[2][5][5] = {{{-0.34215328097343445,-0.17085210978984833,-0.1334684193134308,0.3014412224292755,0.14092323184013367},{0.1764741837978363,0.27049607038497925,-0.1297226846218109,-0.05323846638202667,0.16284404695034027},{0.11559474468231201,-0.13285401463508606,0.1123795211315155,-0.1136157363653183,0.37144899368286133},{0.03854995593428612,-0.27753451466560364,0.14687888324260712,-0.2408742755651474,0.21762782335281372},{0.1532333642244339,-0.10103973746299744,0.2361934930086136,-0.22813524305820465,0.40255531668663025}},{{0.29972895979881287,-0.7337238788604736,0.3636457920074463,-0.40433454513549805,0.24969813227653503},{0.005793417803943157,-0.12310169637203217,0.15185825526714325,0.08865572512149811,-0.07412028312683105},{-0.0655229389667511,0.023182060569524765,-0.06198699027299881,-0.028643373399972916,0.3897289037704468},{-0.04701724275946617,-0.2335687130689621,0.1702326536178589,-0.1748417466878891,-0.23912294209003448},{0.0990956574678421,0.3706609010696411,-0.2555908262729645,0.1604582518339157,-0.025434302166104317}}};
		const float b_layer_5[5] = {-0.04587787389755249,0.3597976565361023,-0.008572002872824669,-0.09324678033590317,-0.21438103914260864};

		// Fill with biases for layer_5
		for (int l = 504; l < L; l++) {
			for (int i = 0; i < 5; i++) {
				x_odd[l][i] = b_layer_5[i];
			}
		}

		// Apply main filter for layer_5
		// x_odd[:,504:] = sum(w[k]@x_even[:,504-(1-k)*8:L-(1-k)*8] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*8;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 5, L-504, 5, 1.0, &w_layer_5[k][0][0], 5, &x_even[504-offset][0], MAX_CH, 1.0, &x_odd[504][0], MAX_CH);
		}


		// Leaky Tanh
		for (int l = 504; l < L; l++) {
			for (int i = 0; i < 5; i++) {
				auto& v = x_odd[i][l];
				x_odd[l][i] = v > 1 ? 1+0.1f*(v-1) : v < -1 ? -1+0.1f*(v+1) : v;
			}
		}


		// auto-generated code for layer layer_6: Conv1d(5, 1, kernel_size=(1,), stride=(1,))
		const float w_layer_6[1][5][1] = {{{-0.01735667884349823},{0.18435421586036682},{-0.10966023802757263},{0.1505274921655655},{-0.06548988074064255}}};
		const float b_layer_6[1] = {-0.07221725583076477};

		// Fill with biases for layer_6
		for (int l = 504; l < L; l++) {
			for (int i = 0; i < 1; i++) {
				x_even[l][i] = b_layer_6[i];
			}
		}

		// Apply main filter for layer_6
		// x_even[:,504:] = sum(w[k]@x_odd[:,504-(0-k)*1:L-(0-k)*1] for k in w.shape[0])
		for (int k = 0; k < 1; k++) {
			int offset = (0-k)*1;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 1, L-504, 5, 1.0, &w_layer_6[k][0][0], 1, &x_odd[504-offset][0], MAX_CH, 1.0, &x_even[504][0], MAX_CH);
		}


		// Copy result back to y
		for (int l = 504; l < L; l++) {
			y[l] = x_even[l][0];
		}
	}
};
