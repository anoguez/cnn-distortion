
#pragma once
extern "C" {
#include <cblas.h>
};

#include <cmath>

struct cnn_dist_v14 {
	const static int latency = 198;
	const static int MAX_L = MAX_BUFFER + latency;
	const static int MAX_CH = 6;
	// About 1.2e-05*(MAX_BUFFER+198) MB of buffer
	float x_even[MAX_L][MAX_CH];
	float x_odd [MAX_L][MAX_CH];

	void operator()(float* x, float* y, int L) {

		// Ensure we don't segfault
		L = L > MAX_L ? MAX_L : L;

		for (int i = 0; i < L; i++) {
			x_odd[i][0] = x[i];
		}

		// auto-generated code for layer layer_0: Conv1d(1, 1, kernel_size=(2,), stride=(2,), bias=False)
		const float w_layer_0[2][1][1] = {{{0.6784594058990479}},{{0.8001580834388733}}};

		// Apply main filter for layer_0
		// x_even[:,1:] = sum(w[k]@x_odd[:,1-(1-k)*1:L-(1-k)*1] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*1;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 1, L-1, 1, 1.0, &w_layer_0[k][0][0], 1, &x_odd[1-offset][0], MAX_CH, beta, &x_even[1][0], MAX_CH);
		}


		// auto-generated code for layer layer_1: Conv1d(1, 1, kernel_size=(2,), stride=(2,), bias=False)
		const float w_layer_1[2][1][1] = {{{0.43327921628952026}},{{0.5530074834823608}}};

		// Apply main filter for layer_1
		// x_odd[:,2:] = sum(w[k]@x_even[:,2-(1-k)*1:L-(1-k)*1] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*1;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 1, L-2, 1, 1.0, &w_layer_1[k][0][0], 1, &x_even[2-offset][0], MAX_CH, beta, &x_odd[2][0], MAX_CH);
		}


		// auto-generated code for layer layer_2: Conv1d(1, 4, kernel_size=(2,), stride=(1,), dilation=(64,), bias=False)
		const float w_layer_2[2][1][4] = {{{0.8210566639900208,0.9939897060394287,-0.6992493867874146,1.0596872568130493}},{{-0.4024716317653656,0.027881789952516556,0.22029271721839905,0.4307902157306671}}};

		// Apply main filter for layer_2
		// x_even[:,66:] = sum(w[k]@x_odd[:,66-(1-k)*64:L-(1-k)*64] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*64;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-66, 1, 1.0, &w_layer_2[k][0][0], 4, &x_odd[66-offset][0], MAX_CH, beta, &x_even[66][0], MAX_CH);
		}


		// auto-generated code for layer layer_3: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(32,), bias=False)
		const float w_layer_3[2][4][4] = {{{-0.09656224399805069,0.04368657246232033,0.29736635088920593,0.10081139951944351},{-0.30820298194885254,-0.33423805236816406,0.1817319095134735,-0.19184273481369019},{0.0064438022673130035,0.1614079624414444,0.28952521085739136,0.07561720162630081},{-0.6232572197914124,0.1878020465373993,-0.07955434918403625,0.030294284224510193}},{{-0.16656145453453064,0.19933991134166718,-0.33006584644317627,0.3900439441204071},{0.27235034108161926,0.0025265079457312822,-1.0594902038574219,0.8986806273460388},{-0.002598509658128023,0.15282343327999115,0.26915258169174194,-0.5948178172111511},{-0.15510979294776917,-0.05487978085875511,-0.687771737575531,0.6780986785888672}}};

		// Apply main filter for layer_3
		// x_odd[:,98:] = sum(w[k]@x_even[:,98-(1-k)*32:L-(1-k)*32] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*32;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-98, 4, 1.0, &w_layer_3[k][0][0], 4, &x_even[98-offset][0], MAX_CH, beta, &x_odd[98][0], MAX_CH);
		}


		// auto-generated code for layer layer_4: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(16,), bias=False)
		const float w_layer_4[2][4][4] = {{{0.1392531841993332,0.020985528826713562,-0.17277421057224274,-0.2545646131038666},{-0.11227410286664963,0.2301621288061142,-0.03921452909708023,-0.3533640205860138},{-0.3534570634365082,-0.24575857818126678,-0.42385333776474,-0.23871386051177979},{0.0369303859770298,0.40964967012405396,0.32878440618515015,-0.1812952607870102}},{{-0.28078705072402954,-0.24399593472480774,-0.4369700253009796,0.20232126116752625},{0.04834625869989395,-0.23522859811782837,0.09344339370727539,-0.05774584412574768},{-0.7417792081832886,0.44068294763565063,0.2749873995780945,0.2698999047279358},{0.9054384231567383,-0.4208278954029083,-0.24422243237495422,0.35806339979171753}}};

		// Apply main filter for layer_4
		// x_even[:,114:] = sum(w[k]@x_odd[:,114-(1-k)*16:L-(1-k)*16] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*16;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-114, 4, 1.0, &w_layer_4[k][0][0], 4, &x_odd[114-offset][0], MAX_CH, beta, &x_even[114][0], MAX_CH);
		}


		// auto-generated code for layer layer_5: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(8,), bias=False)
		const float w_layer_5[2][4][4] = {{{0.007897773757576942,0.37790265679359436,0.3907582759857178,-0.5563096404075623},{-0.018066896125674248,0.024738749489188194,-0.29358139634132385,-0.006810751743614674},{0.22090372443199158,0.12397751212120056,0.06602727621793747,-0.18940918147563934},{0.16816693544387817,-0.13177436590194702,0.133610799908638,-0.16480782628059387}},{{0.6978368759155273,-0.47306394577026367,0.4294319748878479,0.31460121273994446},{-0.26038092374801636,0.45361238718032837,-0.3316538333892822,-0.36100122332572937},{-0.300535649061203,-0.18932929635047913,0.42169520258903503,-0.6430492401123047},{0.39572086930274963,0.21453702449798584,0.2925014793872833,0.11756736785173416}}};

		// Apply main filter for layer_5
		// x_odd[:,122:] = sum(w[k]@x_even[:,122-(1-k)*8:L-(1-k)*8] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*8;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-122, 4, 1.0, &w_layer_5[k][0][0], 4, &x_even[122-offset][0], MAX_CH, beta, &x_odd[122][0], MAX_CH);
		}


		// auto-generated code for layer layer_6: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(4,), bias=False)
		const float w_layer_6[2][4][4] = {{{0.6165027022361755,0.48446688055992126,-0.48845866322517395,-0.07146477699279785},{-0.36926382780075073,-0.3530683219432831,0.6555417776107788,0.1939101368188858},{0.24736618995666504,0.13843196630477905,-0.19190040230751038,0.2797367572784424},{0.5302789211273193,0.4854726493358612,-0.5445020794868469,-0.3524162173271179}},{{-0.39782100915908813,0.062904953956604,0.04055243730545044,0.008200747892260551},{0.04372150078415871,0.19865275919437408,0.0792575553059578,0.5065865516662598},{-0.48546281456947327,-0.1563093066215515,0.4310365617275238,0.02024316042661667},{0.4298800230026245,0.3292829990386963,-0.615772008895874,-0.6195977926254272}}};

		// Apply main filter for layer_6
		// x_even[:,126:] = sum(w[k]@x_odd[:,126-(1-k)*4:L-(1-k)*4] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*4;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-126, 4, 1.0, &w_layer_6[k][0][0], 4, &x_odd[126-offset][0], MAX_CH, beta, &x_even[126][0], MAX_CH);
		}


		// auto-generated code for layer layer_7: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(2,), bias=False)
		const float w_layer_7[2][4][4] = {{{-0.8089165687561035,0.38983243703842163,0.49001580476760864,-0.4274330735206604},{-0.4064443111419678,0.06148005276918411,0.011620728299021721,-0.27509188652038574},{0.2566828727722168,-0.03505426645278931,-0.46837908029556274,0.08483880013227463},{-0.26528602838516235,0.4867038428783417,-0.1438552886247635,0.05662081018090248}},{{-0.651254415512085,0.630473256111145,0.4584406018257141,-0.7086216807365417},{-0.4723760485649109,0.2405204176902771,0.05214950069785118,0.01397074293345213},{0.26247438788414,-0.2878812551498413,-0.6831473112106323,0.28725165128707886},{0.047077637165784836,-0.19409869611263275,-0.36403688788414,0.23503856360912323}}};

		// Apply main filter for layer_7
		// x_odd[:,128:] = sum(w[k]@x_even[:,128-(1-k)*2:L-(1-k)*2] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*2;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-128, 4, 1.0, &w_layer_7[k][0][0], 4, &x_even[128-offset][0], MAX_CH, beta, &x_odd[128][0], MAX_CH);
		}


		// auto-generated code for layer layer_8: Conv1d(4, 6, kernel_size=(1,), stride=(1,))
		const float w_layer_8[1][4][6] = {{{-0.517726480960846,-0.1497553437948227,-0.601555585861206,-0.47990214824676514,-0.5289710164070129,0.6481735706329346},{0.5649950504302979,0.40930142998695374,0.034125521779060364,0.46233513951301575,0.4369466006755829,-0.5418564677238464},{0.21744893491268158,0.3166520893573761,-0.24856078624725342,1.1452522277832031,0.5269436240196228,-0.13282090425491333},{-0.20940759778022766,-0.08579065650701523,-0.0366966687142849,-0.7836785316467285,0.5740340352058411,0.519350528717041}}};
		const float b_layer_8[6] = {-0.20853912830352783,-0.5333102941513062,0.06414302438497543,0.24081538617610931,-0.41779959201812744,-0.034283388406038284};

		// Fill with biases for layer_8
		for (int l = 128; l < L; l++) {
			for (int i = 0; i < 6; i++) {
				x_even[l][i] = b_layer_8[i];
			}
		}

		// Apply main filter for layer_8
		// x_even[:,128:] = sum(w[k]@x_odd[:,128-(0-k)*1:L-(0-k)*1] for k in w.shape[0])
		for (int k = 0; k < 1; k++) {
			int offset = (0-k)*1;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 6, L-128, 4, 1.0, &w_layer_8[k][0][0], 6, &x_odd[128-offset][0], MAX_CH, 1.0, &x_even[128][0], MAX_CH);
		}


		// Soft Sign x/(1+|x|)
		for (int l = 128; l < L; l++) {
			for (int i = 0; i < 6; i++) {
				auto& v = x_even[i][l];
				x_even[l][i] = v > 0 ? v/(1+v) : v/(1-v);
			}
		}


		// auto-generated code for layer layer_9: Conv1d(6, 6, kernel_size=(1,), stride=(1,))
		const float w_layer_9[1][6][6] = {{{0.5354371666908264,0.37499621510505676,0.007503918372094631,0.3149825632572174,0.01135871559381485,-0.4457545876502991},{0.3070872128009796,-0.011432933621108532,-0.22523994743824005,0.4581757187843323,0.1558847874403,-0.6200574636459351},{0.2541894018650055,-0.07169664651155472,0.5539767742156982,0.14953359961509705,-0.19737063348293304,-0.322597473859787},{0.024405959993600845,0.4042755365371704,0.5287810564041138,0.7355707883834839,-0.5967288613319397,-0.06540440022945404},{0.2977360188961029,0.4739341735839844,-0.023686066269874573,-0.024772636592388153,-0.3094560205936432,-0.6429625153541565},{-0.33115652203559875,-0.20079447329044342,-0.41035881638526917,-0.647587239742279,0.42538732290267944,0.07939885556697845}}};
		const float b_layer_9[6] = {0.3092121481895447,0.14733275771141052,0.5379279255867004,0.22166498005390167,0.08200599253177643,0.19095651805400848};

		// Fill with biases for layer_9
		for (int l = 128; l < L; l++) {
			for (int i = 0; i < 6; i++) {
				x_odd[l][i] = b_layer_9[i];
			}
		}

		// Apply main filter for layer_9
		// x_odd[:,128:] = sum(w[k]@x_even[:,128-(0-k)*1:L-(0-k)*1] for k in w.shape[0])
		for (int k = 0; k < 1; k++) {
			int offset = (0-k)*1;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 6, L-128, 6, 1.0, &w_layer_9[k][0][0], 6, &x_even[128-offset][0], MAX_CH, 1.0, &x_odd[128][0], MAX_CH);
		}


		// Soft Sign x/(1+|x|)
		for (int l = 128; l < L; l++) {
			for (int i = 0; i < 6; i++) {
				auto& v = x_odd[i][l];
				x_odd[l][i] = v > 0 ? v/(1+v) : v/(1-v);
			}
		}


		// auto-generated code for layer layer_10: Conv1d(6, 6, kernel_size=(1,), stride=(1,))
		const float w_layer_10[1][6][6] = {{{0.04463871940970421,0.604157567024231,0.5906753540039062,0.8128064870834351,0.03109768033027649,0.5105172395706177},{0.3483627736568451,0.3467356860637665,0.07687589526176453,0.1820523589849472,-0.3890473246574402,0.4201229214668274},{-0.18547695875167847,0.33887434005737305,-0.25983545184135437,0.8706857562065125,-0.23270703852176666,-0.3095713257789612},{0.5358816981315613,0.5429940223693848,0.4343566298484802,0.7630279660224915,-0.5380213856697083,-0.15548960864543915},{-0.25326183438301086,-0.07821349054574966,-0.260383665561676,-0.10253669321537018,0.583807647228241,0.020334353670477867},{-0.6455410718917847,-0.07375041395425797,-0.7293658256530762,-0.18291151523590088,0.4619808495044708,-0.7227693796157837}}};
		const float b_layer_10[6] = {-0.16648489236831665,-0.1955558955669403,-0.29385149478912354,0.5018599033355713,-0.11389266699552536,-0.2017878293991089};

		// Fill with biases for layer_10
		for (int l = 128; l < L; l++) {
			for (int i = 0; i < 6; i++) {
				x_even[l][i] = b_layer_10[i];
			}
		}

		// Apply main filter for layer_10
		// x_even[:,128:] = sum(w[k]@x_odd[:,128-(0-k)*1:L-(0-k)*1] for k in w.shape[0])
		for (int k = 0; k < 1; k++) {
			int offset = (0-k)*1;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 6, L-128, 6, 1.0, &w_layer_10[k][0][0], 6, &x_odd[128-offset][0], MAX_CH, 1.0, &x_even[128][0], MAX_CH);
		}


		// Soft Sign x/(1+|x|)
		for (int l = 128; l < L; l++) {
			for (int i = 0; i < 6; i++) {
				auto& v = x_even[i][l];
				x_even[l][i] = v > 0 ? v/(1+v) : v/(1-v);
			}
		}


		// auto-generated code for layer layer_11: Conv1d(6, 6, kernel_size=(1,), stride=(1,))
		const float w_layer_11[1][6][6] = {{{0.6343011856079102,0.13971859216690063,0.5610294938087463,0.04176964983344078,0.24481797218322754,-0.06940724700689316},{0.15796726942062378,-0.27251723408699036,0.46598851680755615,0.03353229910135269,0.19010642170906067,-0.22330306470394135},{0.6577295064926147,0.06289207190275192,0.567173182964325,0.6133835315704346,0.11619450896978378,0.3594493567943573},{-0.25381073355674744,-0.6296600103378296,0.3957565426826477,-0.201928049325943,-0.7575844526290894,0.6400465965270996},{-0.46514037251472473,0.5977360606193542,-0.67906653881073,-0.5595320463180542,0.4344792664051056,0.4118748903274536},{0.40536409616470337,-0.16426686942577362,0.4371875524520874,0.20641325414180756,-0.03691132739186287,0.129727303981781}}};
		const float b_layer_11[6] = {0.23800264298915863,-0.39719709753990173,0.03556901961565018,0.0651903823018074,0.015024987980723381,0.03374972566962242};

		// Fill with biases for layer_11
		for (int l = 128; l < L; l++) {
			for (int i = 0; i < 6; i++) {
				x_odd[l][i] = b_layer_11[i];
			}
		}

		// Apply main filter for layer_11
		// x_odd[:,128:] = sum(w[k]@x_even[:,128-(0-k)*1:L-(0-k)*1] for k in w.shape[0])
		for (int k = 0; k < 1; k++) {
			int offset = (0-k)*1;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 6, L-128, 6, 1.0, &w_layer_11[k][0][0], 6, &x_even[128-offset][0], MAX_CH, 1.0, &x_odd[128][0], MAX_CH);
		}


		// Soft Sign x/(1+|x|)
		for (int l = 128; l < L; l++) {
			for (int i = 0; i < 6; i++) {
				auto& v = x_odd[i][l];
				x_odd[l][i] = v > 0 ? v/(1+v) : v/(1-v);
			}
		}


		// auto-generated code for layer layer_12: Conv1d(6, 4, kernel_size=(1,), stride=(1,))
		const float w_layer_12[1][6][4] = {{{-0.0681530311703682,-0.48452186584472656,-0.026077767834067345,0.4059435725212097},{-0.4102812111377716,0.06736672669649124,0.2828540802001953,-0.25809356570243835},{-0.4276311993598938,-0.6229277849197388,0.26297900080680847,0.4954388439655304},{-0.05396813526749611,-0.5438238978385925,-0.12158668786287308,0.2562999129295349},{-0.32504501938819885,-0.27199190855026245,0.3753182590007782,-0.2087632715702057},{0.37033405900001526,-0.1325947493314743,-0.16542445123195648,0.12935298681259155}}};
		const float b_layer_12[4] = {-0.17327816784381866,-0.3859173357486725,0.19706228375434875,-0.1822061985731125};

		// Fill with biases for layer_12
		for (int l = 128; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				x_even[l][i] = b_layer_12[i];
			}
		}

		// Apply main filter for layer_12
		// x_even[:,128:] = sum(w[k]@x_odd[:,128-(0-k)*1:L-(0-k)*1] for k in w.shape[0])
		for (int k = 0; k < 1; k++) {
			int offset = (0-k)*1;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-128, 6, 1.0, &w_layer_12[k][0][0], 4, &x_odd[128-offset][0], MAX_CH, 1.0, &x_even[128][0], MAX_CH);
		}


		// auto-generated code for layer layer_13: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(32,), bias=False)
		const float w_layer_13[2][4][4] = {{{0.2932514548301697,-0.2035292237997055,0.05448761582374573,0.04947464168071747},{-0.29156118631362915,-0.1601005345582962,-0.02272619679570198,0.344104528427124},{-0.31445208191871643,0.012832388281822205,-0.018488533794879913,-0.09400586783885956},{0.5364380478858948,0.08770453184843063,-0.26554617285728455,-0.12836110591888428}},{{0.14839580655097961,0.45884913206100464,-0.4776753783226013,0.15463636815547943},{0.10734346508979797,0.559403121471405,-0.4931449592113495,0.1883707493543625},{-0.19698087871074677,-0.29449349641799927,-0.10129071772098541,0.0874013900756836},{0.3338226079940796,-0.20683161914348602,0.48226168751716614,-0.032670579850673676}}};

		// Apply main filter for layer_13
		// x_odd[:,160:] = sum(w[k]@x_even[:,160-(1-k)*32:L-(1-k)*32] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*32;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-160, 4, 1.0, &w_layer_13[k][0][0], 4, &x_even[160-offset][0], MAX_CH, beta, &x_odd[160][0], MAX_CH);
		}


		// auto-generated code for layer layer_14: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(16,), bias=False)
		const float w_layer_14[2][4][4] = {{{0.032096002250909805,0.289840966463089,0.14320991933345795,0.3361026346683502},{-0.17947666347026825,-0.19991573691368103,0.035295434296131134,-0.22638384997844696},{0.03516731411218643,0.21528704464435577,-0.030988791957497597,0.35175639390945435},{0.17319351434707642,-0.138800710439682,-0.19010892510414124,-0.1349349170923233}},{{0.3338812589645386,0.38656654953956604,0.14022934436798096,0.032136812806129456},{-0.4017011821269989,0.36673155426979065,-0.37254613637924194,0.0724664106965065},{0.33951324224472046,-0.5354639887809753,0.3688613176345825,0.32955729961395264},{-0.5486768484115601,0.0013274344382807612,-0.21505995094776154,-0.3176015019416809}}};

		// Apply main filter for layer_14
		// x_even[:,176:] = sum(w[k]@x_odd[:,176-(1-k)*16:L-(1-k)*16] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*16;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-176, 4, 1.0, &w_layer_14[k][0][0], 4, &x_odd[176-offset][0], MAX_CH, beta, &x_even[176][0], MAX_CH);
		}


		// auto-generated code for layer layer_15: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(8,), bias=False)
		const float w_layer_15[2][4][4] = {{{-0.17615358531475067,-0.03902292251586914,-0.2982860505580902,0.1252303272485733},{0.05846046283841133,-0.3112448453903198,0.01054409984499216,0.19672837853431702},{-0.04579020291566849,0.09147054702043533,-0.012158925645053387,0.043970782309770584},{-0.1667112410068512,-0.1314011514186859,-0.5593165159225464,0.25729817152023315}},{{0.49363309144973755,-0.4553369879722595,-0.19842053949832916,-0.2916239798069},{-0.670623242855072,-0.3256876468658447,0.05000219866633415,0.41134339570999146},{0.29419001936912537,-0.20322266221046448,-0.4201195240020752,-0.4388802945613861},{0.20467136800289154,-0.04106825217604637,-0.26030153036117554,-0.08382561802864075}}};

		// Apply main filter for layer_15
		// x_odd[:,184:] = sum(w[k]@x_even[:,184-(1-k)*8:L-(1-k)*8] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*8;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-184, 4, 1.0, &w_layer_15[k][0][0], 4, &x_even[184-offset][0], MAX_CH, beta, &x_odd[184][0], MAX_CH);
		}


		// auto-generated code for layer layer_16: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(4,), bias=False)
		const float w_layer_16[2][4][4] = {{{-0.02884087525308132,0.15409554541110992,-0.34052541851997375,0.07437532395124435},{0.4694945216178894,-0.07975208014249802,0.2552766799926758,-0.20186738669872284},{0.3696052134037018,0.1374681293964386,0.38574427366256714,0.07657492905855179},{0.2572174370288849,0.14556428790092468,0.3209196627140045,-0.13573454320430756}},{{0.5829861760139465,-0.5841293334960938,0.12525318562984467,0.6214399337768555},{-0.24204978346824646,0.051242645829916,0.3198264241218567,-0.008406570181250572},{-0.2552943229675293,0.18951313197612762,0.018092896789312363,-0.35203808546066284},{-0.4613858163356781,0.13133172690868378,-0.4344083070755005,-0.26289480924606323}}};

		// Apply main filter for layer_16
		// x_even[:,188:] = sum(w[k]@x_odd[:,188-(1-k)*4:L-(1-k)*4] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*4;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-188, 4, 1.0, &w_layer_16[k][0][0], 4, &x_odd[188-offset][0], MAX_CH, beta, &x_even[188][0], MAX_CH);
		}


		// auto-generated code for layer layer_17: Conv1d(4, 1, kernel_size=(2,), stride=(1,), dilation=(2,), bias=False)
		const float w_layer_17[2][4][1] = {{{0.45019400119781494},{-0.37431854009628296},{0.2487010955810547},{0.40791693329811096}},{{0.0984632596373558},{0.10953684151172638},{0.2743430733680725},{-0.15992385149002075}}};

		// Apply main filter for layer_17
		// x_odd[:,190:] = sum(w[k]@x_even[:,190-(1-k)*2:L-(1-k)*2] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*2;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 1, L-190, 4, 1.0, &w_layer_17[k][0][0], 1, &x_even[190-offset][0], MAX_CH, beta, &x_odd[190][0], MAX_CH);
		}


		// auto-generated code for layer layer_18: Conv1d(1, 2, kernel_size=(2,), stride=(1,), dilation=(4,), bias=False)
		const float w_layer_18[2][1][2] = {{{-0.8249704241752625,-0.34182196855545044}},{{-0.130922332406044,-0.25125211477279663}}};

		// Apply main filter for layer_18
		// x_even[:,194:] = sum(w[k]@x_odd[:,194-(1-k)*4:L-(1-k)*4] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*4;
			float beta = k == 0 ? 0.0 : 1.0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 2, L-194, 1, 1.0, &w_layer_18[k][0][0], 2, &x_odd[194-offset][0], MAX_CH, beta, &x_even[194][0], MAX_CH);
		}


		// auto-generated code for layer layer_19: Conv1d(2, 1, kernel_size=(2,), stride=(1,), dilation=(2,))
		const float w_layer_19[2][2][1] = {{{-0.3250802457332611},{-0.15753652155399323}},{{-0.49444150924682617},{-0.02016397938132286}}};
		const float b_layer_19[1] = {-0.0012829600600525737};

		// Fill with biases for layer_19
		for (int l = 196; l < L; l++) {
			for (int i = 0; i < 1; i++) {
				x_odd[l][i] = b_layer_19[i];
			}
		}

		// Apply main filter for layer_19
		// x_odd[:,196:] = sum(w[k]@x_even[:,196-(1-k)*2:L-(1-k)*2] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*2;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 1, L-196, 2, 1.0, &w_layer_19[k][0][0], 1, &x_even[196-offset][0], MAX_CH, 1.0, &x_odd[196][0], MAX_CH);
		}


		// Copy result back to y
		for (int l = 196; l < L; l++) {
			y[l] = x_odd[l][0];
		}
	}
};
