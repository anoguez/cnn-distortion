
#pragma once
extern "C" {
#include <cblas.h>
};

#include <cmath>

struct cnn_dist_v10 {
	const static int latency = 510;
	const static int MAX_L = MAX_BUFFER + latency;
	const static int MAX_CH = 4;
	// About 8e-06*(MAX_BUFFER+510) MB of buffer
	float x_even[MAX_L][MAX_CH];
	float x_odd [MAX_L][MAX_CH];

	void operator()(float* x, float* y, int L) {

		// Ensure we don't segfault
		L = L > MAX_L ? MAX_L : L;

		for (int i = 0; i < L; i++) {
			x_odd[i][0] = x[i];
		}

		// auto-generated code for layer layer_0: Conv1d(1, 4, kernel_size=(2,), stride=(1,), dilation=(512,))
		const float w_layer_0[2][1][4] = {{{-1.1536208391189575,0.628654956817627,1.3458139896392822,-0.1601981520652771}},{{1.4794102907180786,1.1237761974334717,1.0121177434921265,1.2800180912017822}}};
		const float b_layer_0[4] = {0.012762965634465218,-0.08317456394433975,0.08762555569410324,-0.011410010978579521};

		// Fill with biases for layer_0
		for (int l = 256; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				x_even[l][i] = b_layer_0[i];
			}
		}

		// Apply main filter for layer_0
		// x_even[:,256:] = sum(w[k]@x_odd[:,256-(1-k)*256:L-(1-k)*256] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*256;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-256, 1, 1.0, &w_layer_0[k][0][0], 4, &x_odd[256-offset][0], MAX_CH, 1.0, &x_even[256][0], MAX_CH);
		}


		// Simple Tanh (polynomial)
		for (int l = 256; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				auto& v = x_even[i][l];
				x_even[l][i] = v > 2 ? 1.3333333333333333f : v < -2 ? -1.3333333333333333f : v - v*v*v*0.08333333333333333f;
			}
		}


		// auto-generated code for layer layer_1: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(256,))
		const float w_layer_1[2][4][4] = {{{-0.6444146633148193,0.5341095924377441,1.1693471670150757,-0.29797419905662537},{-0.7606099843978882,0.851854681968689,0.02283708192408085,-0.21493777632713318},{-0.8647909164428711,0.4492601156234741,-0.010041865520179272,-0.6567767858505249},{-0.6267566084861755,0.7344494462013245,0.8192795515060425,-0.2828373312950134}},{{-0.5818852186203003,0.00807730108499527,-0.4745616018772125,0.8017377257347107},{-0.08899297565221786,-0.5088541507720947,0.12442873418331146,-0.5243502855300903},{0.6480334401130676,-0.33575138449668884,0.0991748794913292,-1.2122753858566284},{-0.3497418165206909,0.14457733929157257,-0.11392421275377274,0.06315888464450836}}};
		const float b_layer_1[4] = {-0.06062621250748634,-0.004108533263206482,-0.03160872310400009,0.10033015161752701};

		// Fill with biases for layer_1
		for (int l = 384; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				x_odd[l][i] = b_layer_1[i];
			}
		}

		// Apply main filter for layer_1
		// x_odd[:,384:] = sum(w[k]@x_even[:,384-(1-k)*128:L-(1-k)*128] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*128;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-384, 4, 1.0, &w_layer_1[k][0][0], 4, &x_even[384-offset][0], MAX_CH, 1.0, &x_odd[384][0], MAX_CH);
		}


		// Simple Tanh (polynomial)
		for (int l = 384; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				auto& v = x_odd[i][l];
				x_odd[l][i] = v > 2 ? 1.3333333333333333f : v < -2 ? -1.3333333333333333f : v - v*v*v*0.08333333333333333f;
			}
		}


		// auto-generated code for layer layer_2: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(128,))
		const float w_layer_2[2][4][4] = {{{0.008414288982748985,0.04409247264266014,0.9567886590957642,-0.19008435308933258},{-0.15040743350982666,-0.036086034029722214,-0.8041687607765198,0.11186239123344421},{-0.11776480078697205,-0.07292412221431732,-0.7677817940711975,0.15353259444236755},{0.015142906457185745,-0.31440216302871704,0.01965813897550106,0.3874399960041046}},{{-0.8656867146492004,-0.4775373935699463,-0.182383731007576,0.13014669716358185},{0.620514452457428,0.5984941124916077,0.32288023829460144,-0.01476090494543314},{0.12810130417346954,0.0723598524928093,0.2925470471382141,1.3003084659576416},{0.3862009346485138,-0.47036516666412354,-0.702420175075531,-0.8393924236297607}}};
		const float b_layer_2[4] = {-0.17151768505573273,-0.1166212186217308,-0.0864039808511734,-0.06268663704395294};

		// Fill with biases for layer_2
		for (int l = 448; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				x_even[l][i] = b_layer_2[i];
			}
		}

		// Apply main filter for layer_2
		// x_even[:,448:] = sum(w[k]@x_odd[:,448-(1-k)*64:L-(1-k)*64] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*64;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-448, 4, 1.0, &w_layer_2[k][0][0], 4, &x_odd[448-offset][0], MAX_CH, 1.0, &x_even[448][0], MAX_CH);
		}


		// Simple Tanh (polynomial)
		for (int l = 448; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				auto& v = x_even[i][l];
				x_even[l][i] = v > 2 ? 1.3333333333333333f : v < -2 ? -1.3333333333333333f : v - v*v*v*0.08333333333333333f;
			}
		}


		// auto-generated code for layer layer_3: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(64,))
		const float w_layer_3[2][4][4] = {{{1.019580364227295,-0.3522683084011078,0.6907705664634705,-0.32399260997772217},{1.0850886106491089,-0.015056981705129147,0.1942996382713318,-0.1931445598602295},{0.8550310730934143,-0.09947860240936279,-0.2474309653043747,-0.29485270380973816},{0.5917925238609314,-0.16357950866222382,0.6359701156616211,0.2747989296913147}},{{0.20361460745334625,0.6952061653137207,-0.4182439148426056,-0.4978305697441101},{0.025814134627580643,0.76618492603302,-0.715203583240509,0.002169959247112274},{1.1651028394699097,0.013131015934050083,-0.3674500584602356,0.5431228280067444},{-0.16722053289413452,0.6445271968841553,0.017977513372898102,0.4963957667350769}}};
		const float b_layer_3[4] = {-0.08815431594848633,-0.21981281042099,-0.09676580131053925,-0.16306865215301514};

		// Fill with biases for layer_3
		for (int l = 480; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				x_odd[l][i] = b_layer_3[i];
			}
		}

		// Apply main filter for layer_3
		// x_odd[:,480:] = sum(w[k]@x_even[:,480-(1-k)*32:L-(1-k)*32] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*32;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-480, 4, 1.0, &w_layer_3[k][0][0], 4, &x_even[480-offset][0], MAX_CH, 1.0, &x_odd[480][0], MAX_CH);
		}


		// Simple Tanh (polynomial)
		for (int l = 480; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				auto& v = x_odd[i][l];
				x_odd[l][i] = v > 2 ? 1.3333333333333333f : v < -2 ? -1.3333333333333333f : v - v*v*v*0.08333333333333333f;
			}
		}


		// auto-generated code for layer layer_4: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(32,))
		const float w_layer_4[2][4][4] = {{{-0.4048973321914673,0.1650034636259079,-0.35563111305236816,0.12857215106487274},{0.49414217472076416,0.430564820766449,-0.35555729269981384,-1.520969033241272},{-0.6091962456703186,-0.05034969747066498,0.35333743691444397,1.1622282266616821},{0.39862293004989624,-0.6440208554267883,0.2393467128276825,-0.4125894010066986}},{{-0.2904133200645447,0.07412242889404297,-0.01870473101735115,0.47724008560180664},{0.29733777046203613,-0.11979133635759354,0.6703011989593506,0.3751241862773895},{-0.15570320188999176,-0.30823153257369995,-0.21518351137638092,1.377952218055725},{-0.05783624202013016,-0.4338233470916748,0.3051212728023529,-0.3249320089817047}}};
		const float b_layer_4[4] = {0.05393246188759804,0.22620682418346405,0.1654854416847229,0.44463178515434265};

		// Fill with biases for layer_4
		for (int l = 496; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				x_even[l][i] = b_layer_4[i];
			}
		}

		// Apply main filter for layer_4
		// x_even[:,496:] = sum(w[k]@x_odd[:,496-(1-k)*16:L-(1-k)*16] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*16;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-496, 4, 1.0, &w_layer_4[k][0][0], 4, &x_odd[496-offset][0], MAX_CH, 1.0, &x_even[496][0], MAX_CH);
		}


		// Simple Tanh (polynomial)
		for (int l = 496; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				auto& v = x_even[i][l];
				x_even[l][i] = v > 2 ? 1.3333333333333333f : v < -2 ? -1.3333333333333333f : v - v*v*v*0.08333333333333333f;
			}
		}


		// auto-generated code for layer layer_5: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(16,))
		const float w_layer_5[2][4][4] = {{{0.016528042033314705,0.5725295543670654,-0.695971667766571,0.19329698383808136},{-0.07373848557472229,-0.08010989427566528,-0.015128138475120068,-0.3440820276737213},{0.12274887412786484,0.8161834478378296,-0.13212266564369202,0.8324187397956848},{0.5417253971099854,0.3332602381706238,-0.04458250850439072,0.15714086592197418}},{{-0.1811928153038025,0.18306557834148407,0.23977193236351013,0.09946946799755096},{-0.13953323662281036,1.056656002998352,0.705707848072052,-0.20012030005455017},{0.018023870885372162,-0.6228611469268799,-0.2600691020488739,-0.17561431229114532},{-0.009583797305822372,-1.0921242237091064,-0.286354124546051,-0.10819923132658005}}};
		const float b_layer_5[4] = {-0.0002562975278124213,-0.1765725165605545,-0.14716081321239471,-0.004297048319131136};

		// Fill with biases for layer_5
		for (int l = 504; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				x_odd[l][i] = b_layer_5[i];
			}
		}

		// Apply main filter for layer_5
		// x_odd[:,504:] = sum(w[k]@x_even[:,504-(1-k)*8:L-(1-k)*8] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*8;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-504, 4, 1.0, &w_layer_5[k][0][0], 4, &x_even[504-offset][0], MAX_CH, 1.0, &x_odd[504][0], MAX_CH);
		}


		// Simple Tanh (polynomial)
		for (int l = 504; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				auto& v = x_odd[i][l];
				x_odd[l][i] = v > 2 ? 1.3333333333333333f : v < -2 ? -1.3333333333333333f : v - v*v*v*0.08333333333333333f;
			}
		}


		// auto-generated code for layer layer_6: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(8,))
		const float w_layer_6[2][4][4] = {{{-0.22466081380844116,-0.03967239707708359,-0.2425822764635086,-0.029478291049599648},{-0.14900930225849152,0.31888073682785034,0.14363758265972137,-0.10430382192134857},{0.12525080144405365,0.332509845495224,0.2111314833164215,0.7031849026679993},{-0.7341748476028442,-0.36580690741539,-0.07986636459827423,0.016177870333194733}},{{-0.114448681473732,-0.35378938913345337,0.25043222308158875,-0.01964701898396015},{-0.7250425219535828,0.0161795224994421,-0.817695677280426,0.17907777428627014},{-0.4279010593891144,0.030097484588623047,-0.3057243525981903,-0.5427618026733398},{-0.25332027673721313,-0.013868509791791439,0.05473801866173744,-0.03247369825839996}}};
		const float b_layer_6[4] = {-0.17795947194099426,0.19301031529903412,0.2805788516998291,0.1686958372592926};

		// Fill with biases for layer_6
		for (int l = 508; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				x_even[l][i] = b_layer_6[i];
			}
		}

		// Apply main filter for layer_6
		// x_even[:,508:] = sum(w[k]@x_odd[:,508-(1-k)*4:L-(1-k)*4] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*4;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-508, 4, 1.0, &w_layer_6[k][0][0], 4, &x_odd[508-offset][0], MAX_CH, 1.0, &x_even[508][0], MAX_CH);
		}


		// Simple Tanh (polynomial)
		for (int l = 508; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				auto& v = x_even[i][l];
				x_even[l][i] = v > 2 ? 1.3333333333333333f : v < -2 ? -1.3333333333333333f : v - v*v*v*0.08333333333333333f;
			}
		}


		// auto-generated code for layer layer_7: Conv1d(4, 4, kernel_size=(2,), stride=(1,), dilation=(4,))
		const float w_layer_7[2][4][4] = {{{-0.11297689378261566,-0.27383917570114136,-0.34084415435791016,-0.03796417638659477},{-0.25850430130958557,0.3559936285018921,-0.2127927988767624,-0.08892223238945007},{0.24212180078029633,-0.051412202417850494,-0.3401375114917755,0.19863319396972656},{-0.08600602298974991,0.30400416254997253,-0.2948901951313019,0.037686727941036224}},{{0.2732493579387665,-0.32071858644485474,-0.6604968309402466,0.034945063292980194},{-0.27890297770500183,0.24241550266742706,-0.04731166362762451,0.061575230211019516},{-0.2019362598657608,0.2216762751340866,-0.7084863185882568,-0.18220338225364685},{0.315178781747818,0.019547048956155777,-0.14086660742759705,0.07789570093154907}}};
		const float b_layer_7[4] = {-0.24369315803050995,0.3834262490272522,0.1158270388841629,-0.02399486117064953};

		// Fill with biases for layer_7
		for (int l = 510; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				x_odd[l][i] = b_layer_7[i];
			}
		}

		// Apply main filter for layer_7
		// x_odd[:,510:] = sum(w[k]@x_even[:,510-(1-k)*2:L-(1-k)*2] for k in w.shape[0])
		for (int k = 0; k < 2; k++) {
			int offset = (1-k)*2;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 4, L-510, 4, 1.0, &w_layer_7[k][0][0], 4, &x_even[510-offset][0], MAX_CH, 1.0, &x_odd[510][0], MAX_CH);
		}


		// Simple Tanh (polynomial)
		for (int l = 510; l < L; l++) {
			for (int i = 0; i < 4; i++) {
				auto& v = x_odd[i][l];
				x_odd[l][i] = v > 2 ? 1.3333333333333333f : v < -2 ? -1.3333333333333333f : v - v*v*v*0.08333333333333333f;
			}
		}


		// auto-generated code for layer layer_8: Conv1d(4, 1, kernel_size=(1,), stride=(1,))
		const float w_layer_8[1][4][1] = {{{0.3125743269920349},{-0.0757007747888565},{0.24328814446926117},{0.0010105129331350327}}};
		const float b_layer_8[1] = {0.14037664234638214};

		// Fill with biases for layer_8
		for (int l = 510; l < L; l++) {
			for (int i = 0; i < 1; i++) {
				x_even[l][i] = b_layer_8[i];
			}
		}

		// Apply main filter for layer_8
		// x_even[:,510:] = sum(w[k]@x_odd[:,510-(0-k)*0:L-(0-k)*0] for k in w.shape[0])
		for (int k = 0; k < 1; k++) {
			int offset = (0-k)*0;
			cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, 1, L-510, 4, 1.0, &w_layer_8[k][0][0], 1, &x_odd[510-offset][0], MAX_CH, 1.0, &x_even[510][0], MAX_CH);
		}


		// Copy result back to y
		for (int l = 510; l < L; l++) {
			y[l] = x_even[l][0];
		}
	}
};
